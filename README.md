# CS-300-DSA-Analysis-and-Design
- Dayne R Firth II \
CS-300 DSA Analysis and Design \
2025 C-2

 - What was the problem you were solving in the projects for this course?
   - The main problem I was solving was how to load, organize, and search for course information efficiently from a data file so that users could retrieve course details and prerequisites quickly. Understanding which data structure to use in a what scenario.
 - How did you approach the problem? Consider why data structures are important to understand.
   - I approached this by looking at the needs and what is important to make sure that the product is functional and agile where it needs to be.  Understanding data structures is essential because choosing the wrong one can make a program inefficient or overly complex. For example, using a vector alone would have required linear searches, slowing down the program as more data was added.
 - How did you overcome any roadblocks you encountered while going through the activities or project?
    - Any roadblocks that I ran into I went to resources like stack overflow, I have a coworker that is part of our tech development and he was been a huge resource on getting roadblocks removed. He points me in the right direction and gives me the feedback I need.
  - How has your work on this project expanded your approach to designing software and developing programs?
    - Understanding what scenario each data structure is used for and what the advantages and disadvantages of them.  Understanding the end goal and the function of the program before embarking on the development part helps understand.  Make sure you aren’t redoing everything cause it didn’t work.
- How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
    - Working on this project has significantly improved the way I write programs, especially by applying object-oriented programming principles. I learned the value of separating concerns by using classes to encapsulate related data and behaviors.  This made the program easier to maintain and find bugs because changes to one part didn’t affect unrelated parts of the code.
